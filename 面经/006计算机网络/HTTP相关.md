# 持久连接和非持久连接

HTTP/1.0 使用非持久连接，HTTP/1.1 默认使用持久连接。

## 非持久连接

我们可以看一下非持久连接下从服务器获取到一个 HTML 页面和十张 JPEG 图片的过程。假设 HTML 文件的 `url:www.phei.com/somepath/index.html` 。

1. HTTP 客户端初始化一个与服务器主机 `www.phei.com` 中的 HTTP 服务器的 TCP 连接。服务器默认用 80 端口监听客户端的请求。
2. 客户端发出请求，请求路径 `/sompath/index.html` 。
3. 服务器接收到请求，从自己主机的内存或硬盘中取出对应 `index.html` ，结果同一个 Socket 发出包含该对象的响应消息。服务端会告知 TCP 不要关闭连接。
4. 客户端收到响应消息后，TCP 连接就终止了。==客户端解析了 HTML 文件，发现了十张 JPEG 对象的引用。通过上述 4 个步骤再把这个图片文件给取过来。==

==上述步骤之所以被称为非持久连接，因为每次服务器发出一个对象后，TCP 连接就被关闭了，也就是每个 TCP 连接只能一次请求消息和一次响应消息。所以上述步骤会发生 11 次 TCP 连接。== 当然，浏览器都有多路复用，所以这 11 次都可能由浏览器默认，5-10 个一组并行的 TCP 连接。

往返时间(Round Trip Time，简称 RTT)，就是一个小分组从客户 => 服务端  => 客户端所花费的时间，所以过程中：

1. 三次握手的前两次：客户端 => 服务端 => 客户端，客户端发送一个小的亢余消息用来主动请求服务端，服务端也发送一个小消息向客户端回应，消耗 1 个 RTT。
2. 第三次握手，客户端就直接发送具体的请求消息，然后请求中把最后一次的确认捎带在里面。服务端收到后把 HTML 文件发送过去。所以这一轮要花费 1 个 RTT 加上发送 HTML 文件的时间。

所以一次 TCP 连接总消耗 2 个 RTT 加上这个 HTML 文件的时间。

### 缺点

1. 每次请求都要维护一个新的连接。
2. 每次的连接，TCP 都会在客户端和服务端分配一个 TCP 缓冲区，维持 TCP 变量。想象一下每次同时数百个客户请求打过来，每个客户端还有十几条请求，这个负担很重，并且==每个对象都有 2 RTT 的响应延迟才能收到内容 —— 1 个 RTT 用来建立 TCP，另 1 个用来请求和接收对象。== 这个被称为 TCP 慢启动。

## 持久连接

服务器发出响应后会让 TCP 连接继续打开着。这个连接会限制一段特定时间后关闭，这段时间通常可以配置。==持久连接分为不带流水线（without pipelining）和带流水线（with pipelining）两个版本。==

- 不带流水线：客户端只能在接收到前一个请求的响应后才会发送新的请求。
- 带流水线：客户端每遇到一个引用就发一个请求，所以客户端一个接一个连续发出各个引用对象的请求。==所以就像流水线作业，服务端也一个接一个回应，所以缓启动延迟也比较小。发送了第一个对象之后，就不会再有延迟。== 







# HTTP2.0 和1.X 对比

- HTTP2 使用二进制传输，HTTP1.X 使用文本(字符串)传输。
- HTTP2 支持多路复用，==因为有流ID==，所以同一个 http 请求实现多个 http 请求成为可能。
- HTTP2 可以进行压缩头部，然后服务端和客户端共同维护一张表，所有字段都记录在表中。
- HTTP2 可以服务端主动推送消息！

























