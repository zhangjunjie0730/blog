# 1. XSS 和 CSRF

- XSS：全称==跨站脚本攻击(Cross Site Scripting)== 。当用户浏览器网页时，脚本就会执行，攻击获得 Cookie、导航到恶意网站、携带木马等。
- CSRF：==跨站请求伪造(Cross-site request forgery)==。劫持用户 Cookie 骗取服务器信任。伪造请求发送服务器。



## XSS

XSS 分为三种，反射型(非持久型)、存储型(持久型)、基于 DOM。

### 反射型

诱导用户点击一个恶意链接，或者提交一个表单。



### 存储型

XSS 会得到用户输入的数据。



### 基于 DOM

通过恶意脚本修改页面的 DOM 结构，纯粹发生在客户端。



### 防范

- HttpOnly 表示只能是 HTTP 提供 Cookie 字段，服务端才会响应。防止第三方劫持了 Cookie 之后盗用。
- 输入检查：服务端不相信用户任何输入，对其进行检查过滤和转义。
- 输出检查：





## CSRF

==浏览器有两种 Cookie==：

- Session Cookie：==会话期结束后过期！也就是浏览器关闭后删除。==
- Permanent Cookie：有一定的过期时间和有效期。

### 防范

- 验证码。
- Referer Check：HTTP 头部有个 `Referer` 字段表示该请求的地址，服务端检查是否是合法源。
- 可以在 HTTP 请求参数中产生随机的 token，攻击者拿到 cookie 并不知道请求参数也有加密，所以 token 不正确时就不会响应到内容。







## 🌟React 中对 XSS 优化







## 参考

1. https://blog.csdn.net/m0_37631322/article/details/81346335
2. https://mp.weixin.qq.com/s/yf0jhXiCXw8oTbjoUI3tYw



# 2. HTTP 和 HTTPS

## 基本概念

- HTTP：基于 TCP ，用于从 WWW 服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更高效、使网络传输减少。
- HTTPS：HTTP 的安全版，用 SSL 加密。





## HTTP 原理

1. 请求/响应式协议。
2. 无连接：限制每次连接只处理一个请求，请求完成后收到应答就断开连接。为了弥补无连接和无状态，用到 Cookie 和 Session。

### URL 和 URI 的区别

- URI(Uniform Resource Identifier)：统一资源标识符。==用来标识具体资源的，通过 URI 知道具体是什么资源。==
- URL(Uniform Resource Location)：统一资源定位符。用来标识一个具体的资源位置，例如互联网的每个文件都有唯一的 URL。



### 状态码

- 200 OK —— 客户端请求成功。
- 301 —— 资源被永久转移到其他 URL(重定向)。
- 400 Bad Request —— 客户端请求有语法错误，服务端不理解。
- 404 —— 请求资源不存在。
- 500 —— 服务端错误，处理请求时发生错误。
- 503 Server Unavailable —— 服务端当前不能处理客户端的请求，过段时间能恢复正常。



### POST 请求类型 `content-type`

- `application/json`：内容是 JSON 字符串。
- `application/x-www-form-urlencoded`：浏览器原生 form 表单
- `multipart/form-data`：当表单有文件时用到。
- `text/xml`：











## HTTPS 工作原理

客户端在使用 HTTPS 方式与 Web 服务器通信有几个步骤：

<img src="images/%E6%88%AA%E5%B1%8F2021-02-16%20%E4%B8%8B%E5%8D%8810.48.10.png" alt="截屏2021-02-16 下午10.48.10" style="zoom:33%;" />

1. 客户用 https 的 URL 访问服务器，请求与服务器建立 SSL 连接。
2. 服务器收到客户端请求后，把网站证书信息(包括公钥)响应给客户端。
3. 客户端建立会话密钥，利用服务器公钥对会话加密，传输信息给服务器。
4. 服务器利用自己的私钥解密。



### SSL 和 TLS

- Secure Sockets Layer 安全套接字协议。
- Transport Layer Sercurity 传输层安全



### 缺点

- HTTPS 协议多次握手，导致页面加载时间延长近 50%。
- HTTPS 连接缓存不如 HTTP 高效，增加开销和工号。
- 申请 SSL 证书要钱，功能越强大费用越高。
- SSL 算法消耗 CPU 资源，消耗大。









## 区别

- http 默认端口 80，https 默认端口443。

# 参考

1. https://zhuanlan.zhihu.com/p/72616216





# 3. 跨域方案

```js
URL                                      说明                    是否允许通信
http://www.domain.com/a.js
http://www.domain.com/b.js         同一域名，不同文件或路径         允许
http://www.domain.com/lab/c.js

http://www.domain.com:8000/a.js
http://www.domain.com/b.js         同一域名，不同端口              不允许
 
http://www.domain.com/a.js
https://www.domain.com/b.js        同一域名，不同协议              不允许
 
http://www.domain.com/a.js
http://192.168.4.12/b.js           域名和域名对应相同ip            不允许
 
http://www.domain.com/a.js
http://x.domain.com/b.js           主域相同，子域不同              不允许
http://domain.com/c.js
 
http://www.domain1.com/a.js
http://www.domain2.com/b.js        不同域名                       不允许
```







## jsonp 跨域

能利用 JSONP 的原理：浏览器允许不同域名下通过 html 标签加载静态资源(为了减轻服务器压力，把资源都分发到不同域名服务器下)。所以。动态创建 `script` 标签，然后定义回调函数，服务端响应这个函数直接执行。

- 服务器把数据装进 js 格式的文件中，然后在客户端调用和处理。
- 用 JSON 格式的文件，客户端能原生处理。
- ==客户端定义一个回调函数，服务端执行，就能响应到数据。==

客户端：

```html
<script>
	let script = document.createElement('script');
  script.type = 'text/javascript';
  
  // 网址中带上callback参数，
  script.src = 'http://www.domain2.com:8080/login&callback=handleCallback';
  document.head.appendChild(script);
  
  function handleCallback(res){
		alert("姓名：" + res.username + "，年龄：" + res.age);
  }
</script>
```

服务端返回同样的函数名，就能执行这个全局函数：

```js
app.on('/login', (req, res) => {
	let params = qs.parse(req.url.split('?')[1]);
  let fn = params.callback;
  
  res.writeHead(200, {'Content-Type': 'text/javascript'});
  res.write(fn + '(' + JSON.stringify(params) + ')');
  res.end();
})
app.listen('3000');
console.log('Server is running at port 3000');
```







## CORS

普通跨域时，只需要服务端设置 `Access-Control-Allow-Origin` 就行，前端无需设置。但是带 `cookie` 的请求，前后端都要设置。`CORS` 可以实现。

前端设置：

```js
xhr.withCredentials = true;
// 或者利用 open 方法中的第三个参数
xhr.open('post', 'http://www.domain2.com:8080/login', true);
```





## WebSocket

WebSocket 协议允许跨域。







# 4. URL 输入后发生了什么

## 大致流程

1. URL 解析。
2. DNS 查询。
3. TCP 连接。
4. 处理请求。
5. 接受响应。
6. 渲染页面。



## 1. URL 解析



1. 地址解析：浏览器判断是否是合法的 URL，并且根据内容，浏览器给出字符编码等操作。

2. HSTS(HTTP Strict Transport Security) HTTP 严格传输，这是网站用来声明只能使用安全连接(HTTPS)访问的方法。

   > ==HSTS 工作原理== ：
   >
   > 1. 输入 `www.test.com` ，而不是 `http://www.test.com` 时，浏览器会自动加上 HTTP 协议。然后发送该请求。
   > 2. 浏览器收到 301 状态码要求重定向到 HTTPS 站点。
   > 3. 浏览器使用 `https://www.test.com` ，并且设置HSTS 安全策略响应头，然后再发送。

3. 检查缓存：

<img src="images/%E6%88%AA%E5%B1%8F2021-02-17%20%E4%B8%8A%E5%8D%889.27.14.png" alt="截屏2021-02-17 上午9.27.14"  />



## 2. DNS 查询

![截屏2021-02-17 上午9.35.27](images/%E6%88%AA%E5%B1%8F2021-02-17%20%E4%B8%8A%E5%8D%889.35.27.png)



1. 浏览器缓存：浏览器会先检查自己是否有这个域名的缓存。
2. 操作系统也有 DNS 缓存，检查本地 Hosts 文件里。
3. 路由器缓存。
4. ISP DNS 缓存：Internet Servive Provider 因特网服务提供商。
5. 到根域名服务器查询

![截屏2021-02-17 上午9.38.27](images/%E6%88%AA%E5%B1%8F2021-02-17%20%E4%B8%8A%E5%8D%889.38.27.png)



## 3. TCP 连接

## 4. 请求和响应

## 5. 渲染页面

注意：CSS 会阻塞 JS 执行，JS 会阻塞 DOM 解析。所以为了避免这种情况，

- CSS 资源排在 JS 资源最前面。
- JS 放在 HTML 最底部。







# 5. 浏览器缓存

浏览器缓存也就是常说的 HTTP 缓存机制。浏览器根据 HTTP 的报文中缓存标识对资源进行缓存，能有效减轻服务器压力。

<img src="images/%E6%88%AA%E5%B1%8F2021-02-17%20%E4%B8%8B%E5%8D%8810.46.19.png" alt="截屏2021-02-17 下午10.46.19" style="zoom:50%;" />

1. 浏览器第一次向服务器发送请求并获得响应后，响应报文中的 ==HTTP 头中缓存标识== 和请求结果，根据 ==缓存标识== 来决定是否进行缓存。
2. 然后按照图片方式存入缓存。





## 缓存方式

将分为强缓存和协商缓存。

### 1. 强制缓存

**强制缓存**就是向浏览器缓存查找该请求的缓存结果，













