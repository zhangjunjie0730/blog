# 01. HTTP2优点

## HTTP 优缺点

### 优点

1. 灵活可扩展：能传输文本、图片、视频等任意数据，非常方便。
2. 可靠传输：HTTP 基于 TCP/IP，所以由于 TCP 的可靠，所以继承下来的。
3. 请求应答模式。
4. 无状态：服务器很容器组成集群。

### 缺点

1. 无状态：无法记录请求的对象信息，得通过 `cookie` 来保存状态。
2. 明文传输：安全问题。
3. 队头阻塞问题：由请求—应答模式导致，所以会阻塞。



## HTTPS

多了一层 SSL(安全套接字层) 协议。通过两种加密方式：

- 非对称加密：客户端共享公钥，服务端掌握私钥。客户端信息智能服务端解密。
- 对称加密：服务端和客户端共享密钥，所以服务端要维护多个密钥。



### SSL 握手过程

1. TCP 连接建立之后，客户端发来一个 `Client Hello` 发起 SSL 握手，消息中包括客户端支持的加密方法、压缩方法、SSL 协议版本，和用来生成对话密钥的随机数。
2. 服务端会回复 `Server Hello` ，内容包括：客户端选择的加密协议版本和加密方法，SSL 证书和用于生成对话密钥的随机数。
3. 客户端收到后先验证证书是否有效，从证书中取出来服务端的公钥，然后在发送消息：服务端公钥加密的随机数，告知服务端握手结束。
4. 服务端收到客户端消息后，使用私钥解密发过来的第二个随机数，同时发送结束握手消息。

所以客户端和服务端都持有三个随机数(客户端发了两个，服务端发了一个)。通过这三个随机数，生成一个==对话密钥(session key)==。

> 为什么用三个随机数产生对话密钥？
>
> 因为证书是静态的，增加随机数可以使密钥具有随机性。





## HTTP2 优点

1. **头部压缩。**
2. **多路复用。**
3. **服务器推送。**
4. **可以设置请求优先级。**

### 1. 头部压缩

报文头部字段一般都很长，HTTP2 进行优化，可以压缩。

1. 为了方便压缩加入==伪头字段==。比如：`:authority`、`:method`、`:status` 。
2. 服务端和客户端共同维护一张哈希表：用索引保存头部字段，极大精简。
3. ==哈夫曼编码==能让出现次数多的自负索引尽可能短，达到高压缩率。

### 2. 多路复用

HTTP 队头阻塞问题根本是因为请求—响应模型。

并发连接和域名分片没有从 HTTP 层次上解决问题，只是增加了 TCP 长连接的个数。

> 并发连接：浏览器一个域名采用 6-8 个 TCP 连接，并发 HTTP 请求。
>
> 域名分片：`content1.abc.com` 和 `content2.abc.com` 。多分出来二级域名后，他们都指向同一个服务器的话，增加了并发长连接数。

多路复用解决的是 HTTP 请求—响应层面队头阻塞。

==二进制传帧==：明文传输对机器有些麻烦，直接把报文转成二进制格式，传输 01 串，方便机器解析。==分帧之后，每个帧乱序传递，不存在阻塞的问题，到达地方进行组帧。==

==这种方式还可以给通过字段设置优先级和流量控制，实现优先级。==

### 3. 服务器推送

浏览器可以在刚请求 HTML 的时候就提前把可能会用到的 JS、CSS 文件发送给客户端，减少等待的延迟，这就是==服务器推送==。

## 参考

1. [SSL 握手过程](https://www.jianshu.com/p/de69abce0710?utm_campaign)
2. [HTTP2](https://alvin.run/blogs/protocol/http2/push.html)





# 02.webSocket

## 1. 什么是 webSocket

WebSocket 是和 HTTP 并列的通信协议，基于 TCP 的全双工通信。HTTP 只能实现客户端请求，服务端响应这种单项通信。但是 WebSocket 能双向通信，==服务端能主动将消息推送到客户端==。其他特点：

- 握手阶段采用 HTTP 协议。
- 数据格式轻量，性能开销小。
- 更好二进制支持，能发送文本和二进制数据。
- 没有同源限制，可以与任意服务器通信。
- 协议标识符是 ws(如果加密就是 wss)，请求地址就会是后端支持 webSocket 的 API 。



## 几种实时通信的方法

1. ==AJAX 轮询==：定时发送请求，无限循环发送，一旦服务端有最新消息，就可以被客户端获取。
2. ==Long Polling 长轮询==：客户端发起长轮询请求，服务端没有数据返回，会保持一个长连接，等到有数据，就返回客户端。客户端断开，再发起一个长轮询，再进行重复过程。

上述两种方式缺点：开销大，被动。高并发下，服务端压力大。



## WebSocket 连接过程

客户端发起 HTTP 握手，告诉服务端进行 webSocket 通讯，告知协议版本。服务端升级到对应协议版本。如果有数据需要推送，会主动推送给客户端。

==客户端请求头部Request Headers==：

```js
Accept-Encoding: gzip, deflate, br
Accept-Language: zh,zh-TW;q=0.9,en-US;q=0.8,en;q=0.7,zh-CN;q=0.6
Cache-Control: no-cache
Connection: Upgrade // 表示要升级协议
Host: 127.0.0.1:3000
Origin: http://localhost:3000
Pragma: no-cache
Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits

// 对应服务端响应头的Sec-WebSocket-Accept，相当于一个钥匙一把锁
Sec-WebSocket-Key: bwb9SFiJONXhQ/A4pLaXIg== 
// 协议版本号，如果服务端不支持就返回 Sec-WebSocket-Version，里面包含服务端支持的版本号
Sec-WebSocket-Version: 13 
// 表示要升级协议
Upgrade: websocket 
```

==服务端响应头部Response Headers==：

```js
Connection: Upgrade
// 表示愿意连接，这个值根据请求的Sec-WebSocket-Key计算出来
Sec-WebSocket-Accept: 2jrbCWSCPlzPtxarlGTp4Y8XD20=
Upgrade: websocket
```

## 参考

1. https://zhuanlan.zhihu.com/p/74326818







# 03. 死锁和死锁条件

## 死锁

两个或以上的进程(线程)在执行过程，因为争夺资源而造成一种相互等待的现象，若无外力，它们将无法推进下去。

产生原因：

1. 系统资源不足。
2. 进程(线程)推进顺序不恰当。
3. 资源分配不当。



## 形成场景

1. 忘记释放锁：在申请锁和释放锁之间直接 return
2. 单线程重复申请锁。
3. 多线程多锁申请：两个线程，两个锁，他们都已经有锁了，但是想申请对方的锁。
4. 环形锁的申请，多个线程申请锁的顺序形成相互依赖的环形。



## 死锁条件

1. **互斥条件：**一段时间内，该资源只能被一个进程占有。
2. **请求和保持条件：**

















