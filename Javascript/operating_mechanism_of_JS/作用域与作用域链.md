# 作用域与作用域链

## 作用域链

当访问一个变量时，解释器会首先在当前作用域查找标示符，如果没有找到，就去父作用域找，直到找到该变量的标示符或者不在父作用域中，这就是作用域链。如果找不到就会抛出**Reference Error**。作用域链的顶端是**全局对象**，在全局环境中定义的变量就会绑定到全局对象中。

作用域链和原型继承查找时的区别：如果去查找一个普通对象的属性，但是在当前对象和其原型中都找不到时，会返回**undefined**；但查找的属性在作用域链中不存在的话就会抛出**Reference Error**。

## 活跃对象AO

每个函数都有自己的执行上下文环境，当代码在这个环境中执行时，会创建变量对象的作用域链，作用域链是一个对象列表或对象链，它保证了变量对象的有序访问。

作用域链的开始是当前代码执行环境的变量对象，常被称之为“活跃对象”（**AO**），变量的查找会从第一个链的对象开始，如果对象中包含变量属性，那么就停止查找，如果没有就会继续向上级作用域链查找，直到找到全局对象中



## 作用域

在ES6前有**全局作用域**和**局部作用域**，但是没有**块级作用域**（catch只在其内部生效），**局部变量的优先级高于全局变量**。**这就是为什么下面的let能正常显示0、1、2（let产生块级作用域）**

### 变量提升

```js
var scope="global";
function scopeTest(){
    console.log(scope);
    var scope="local"  
}
scopeTest(); //undefined
```

上面的代码输出是 `undefined`，这是因为局部变量 `scope`变量提升了，等效于下面

```js
var scope="global";
function scopeTest(){
    var scope;
    console.log(scope);
    scope="local"  
}
scopeTest(); //undefined
```







# 闭包

`闭包` 是指有权访问另外一个函数作用域中的变量的函数。

关键在于下面两点：

- 是一个函数
- 能访问另外一个函数作用域中的变量



## 闭包三特性

1. 闭包可以访问当前函数以外的变量

   内部函数getData访问到了外部的date：

   ```javascript
   function getOuter(){
     var date = '815';
     function getDate(str){
       console.log(str + date);  //访问外部的date
     }
     return getDate('今天是：'); //"今天是：815"
   }
   getOuter();
   ```

   

2. 即使外部函数已经返回，闭包仍能访问外部函数定义的变量

   本质上：getDate在返回阶段没有执行，是在调用阶段执行的。可以在外部传递给getDate函数参数str

   ```js
   function getOuter(){
     var date = '815';
     function getDate(str){
       console.log(str + date);  //访问外部的date
     }
     return getDate;     //外部函数返回
   }
   var today = getOuter();
   today('今天是：');   //"今天是：815"
   today('明天不是：');   //"明天不是：815"
   ```



3. 闭包可以更新外部变量的值

   ```js
   function updateCount(){
     var count = 0;
     function getCount(val){
       count = val;
       console.log(count);
     }
     return getCount;     //外部函数返回
   }
   var Count = updateCount();
   Count(815); //815
   Count(816); //816
   ```



## 闭包能实现的原理

**虽然创建它的上下文被销毁，但是它的活动对象仍然存在**

函数执行上下文时维护了一个**作用域链**（数组）

```js
fContext = {
    Scope: [AO, checkscopeContext.AO, globalContext.VO],
}
```

当函数执行时，会一级一级向上找（这是作用域的原理）。但是及时`checkscopeContext`没有用了被销毁了，但是JS仍然会让`checkscopeContext.AO`（活动对象） 活在内存中, 函数依然可以通过函数的作用域链找到它，这就是闭包实现的**关键**。



## 面试经典题1

由于作用域链机制的影响，闭包只能取得内部函数的最后一个值，这引起的一个副作用就是如果内部函数在一个循环中，那么变量的值始终为最后一个值。

```js
var data = [];

for (var i = 0; i < 3; i++) { // 注意这里是var 用let的时候会不同！上面有原因！
  data[i] = function () {
    console.log(i);
  };
}

data[0]();
data[1]();
data[2]();
```

**分析**：执行放在了下面，当for循环完了之后才执行。所以都打印3。

**原理**：循环结束后，全局执行上下文的VO（活动对象）是

```js
globalContext = {
    VO: {
        data: [...],
        i: 3 
    }
}

// data[0]的作用域链为
data[0]Context = {
    Scope: [AO, globalContext.VO]
}
```



### 解决办法

1. **立即执行函数**

```js
for (var i = 0; i < 3; i++) {
    (function(num) {
        setTimeout(function() {
            console.log(num);
        }, 1000);
    })(i);
}
// 0
// 1
// 2
```



2. **返回一个匿名函数赋值**

为了访问到内部函数的每一个 i ，所以要使用闭包。将 `data[i]` 返回一个函数。其实就是立即执行。

```js
var data = [];

for (var i = 0; i < 3; i++) {
  data[i] = (function (i) {
      return function(){
          console.log(i);
      }
  })(i); // 立即执行函数
}

data[0]();	// 0
data[1]();	// 1
data[2]();	// 2
```

这时候的作用域链就多了这个匿名函数的，用来存储每一个i

```js
data[0]Context = {
    Scope: [AO, 匿名函数Context.AO, globalContext.VO]
}

// 匿名函数执行上下文的AO为：
匿名函数Context = {
    AO: {
        arguments: {
            0: 0,
            length: 1
        },
        i: 0
    }
}
```



3. **使用ES6中的let**

let产生块级作用域

```js
var data = [];

for (let i = 0; i < 3; i++) {
  data[i] = function () {
    console.log(i);
  };
}

data[0]();
data[1]();
data[2]();
```

**原理**：

```js
var data = [];// 创建一个数组data;

// 进入第一次循环
let i = 0; // 注意：因为使用let使得for循环为块级作用域
// 此次 let i = 0 在这个块级作用域中，而不是在全局环境中
data[0] = function() {
  console.log(i);
};
```

循环时，`let `声明 `i` ,所以整个块是块级作用域，那么`data[0]`这个函数就成了一个闭包。let存在时，这个for循环块是块级作用域，而不是全局作用域。

因为for不具有块级作用域，所以用 var 声明的 i 实际上全局变量！所以循环时都是对 i 进行了新的赋值。但 let 不同，它可以产生块级作用域。

```js
for (var i = 0; i < 3; i++) {
  console.log(111);
}
console.log(i); // 这里可以访问到i = 3
```



## 面试经典题2

对比下面两个代码，`checkscope()`执行完成后，闭包`f`所引用的自由变量`scope`会被垃圾回收吗？为什么？

```js
// 代码1
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}

checkscope()();   // 关键


// 代码2
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}

var foo = checkscope(); // 关键
foo();    
```

**解释**：`checkscope()`执行完成后，代码1中自由变量特定时间之后**回收**，代码2中自由变量**不回收**。



















